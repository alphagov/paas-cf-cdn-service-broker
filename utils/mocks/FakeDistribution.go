// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/alphagov/paas-cdn-broker/utils"
	"github.com/aws/aws-sdk-go/service/cloudfront"
)

type FakeDistribution struct {
	CreateStub        func(string, []string, string, int64, utils.Headers, bool, map[string]string) (*cloudfront.Distribution, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 string
		arg2 []string
		arg3 string
		arg4 int64
		arg5 utils.Headers
		arg6 bool
		arg7 map[string]string
	}
	createReturns struct {
		result1 *cloudfront.Distribution
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 *cloudfront.Distribution
		result2 error
	}
	DeleteStub        func(string) (bool, error)
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 string
	}
	deleteReturns struct {
		result1 bool
		result2 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	DisableStub        func(string) error
	disableMutex       sync.RWMutex
	disableArgsForCall []struct {
		arg1 string
	}
	disableReturns struct {
		result1 error
	}
	disableReturnsOnCall map[int]struct {
		result1 error
	}
	GetStub        func(string) (*cloudfront.Distribution, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 string
	}
	getReturns struct {
		result1 *cloudfront.Distribution
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 *cloudfront.Distribution
		result2 error
	}
	ListDistributionsStub        func(func(cloudfront.DistributionSummary) bool) error
	listDistributionsMutex       sync.RWMutex
	listDistributionsArgsForCall []struct {
		arg1 func(cloudfront.DistributionSummary) bool
	}
	listDistributionsReturns struct {
		result1 error
	}
	listDistributionsReturnsOnCall map[int]struct {
		result1 error
	}
	SetCertificateAndCnameStub        func(string, string, []string) error
	setCertificateAndCnameMutex       sync.RWMutex
	setCertificateAndCnameArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []string
	}
	setCertificateAndCnameReturns struct {
		result1 error
	}
	setCertificateAndCnameReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateStub        func(string, *[]string, string, *int64, *utils.Headers, *bool) (*cloudfront.Distribution, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 string
		arg2 *[]string
		arg3 string
		arg4 *int64
		arg5 *utils.Headers
		arg6 *bool
	}
	updateReturns struct {
		result1 *cloudfront.Distribution
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 *cloudfront.Distribution
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDistribution) Create(arg1 string, arg2 []string, arg3 string, arg4 int64, arg5 utils.Headers, arg6 bool, arg7 map[string]string) (*cloudfront.Distribution, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 string
		arg2 []string
		arg3 string
		arg4 int64
		arg5 utils.Headers
		arg6 bool
		arg7 map[string]string
	}{arg1, arg2Copy, arg3, arg4, arg5, arg6, arg7})
	stub := fake.CreateStub
	fakeReturns := fake.createReturns
	fake.recordInvocation("Create", []interface{}{arg1, arg2Copy, arg3, arg4, arg5, arg6, arg7})
	fake.createMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDistribution) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeDistribution) CreateCalls(stub func(string, []string, string, int64, utils.Headers, bool, map[string]string) (*cloudfront.Distribution, error)) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeDistribution) CreateArgsForCall(i int) (string, []string, string, int64, utils.Headers, bool, map[string]string) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeDistribution) CreateReturns(result1 *cloudfront.Distribution, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 *cloudfront.Distribution
		result2 error
	}{result1, result2}
}

func (fake *FakeDistribution) CreateReturnsOnCall(i int, result1 *cloudfront.Distribution, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 *cloudfront.Distribution
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 *cloudfront.Distribution
		result2 error
	}{result1, result2}
}

func (fake *FakeDistribution) Delete(arg1 string) (bool, error) {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDistribution) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeDistribution) DeleteCalls(stub func(string) (bool, error)) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeDistribution) DeleteArgsForCall(i int) string {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDistribution) DeleteReturns(result1 bool, result2 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDistribution) DeleteReturnsOnCall(i int, result1 bool, result2 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDistribution) Disable(arg1 string) error {
	fake.disableMutex.Lock()
	ret, specificReturn := fake.disableReturnsOnCall[len(fake.disableArgsForCall)]
	fake.disableArgsForCall = append(fake.disableArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DisableStub
	fakeReturns := fake.disableReturns
	fake.recordInvocation("Disable", []interface{}{arg1})
	fake.disableMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDistribution) DisableCallCount() int {
	fake.disableMutex.RLock()
	defer fake.disableMutex.RUnlock()
	return len(fake.disableArgsForCall)
}

func (fake *FakeDistribution) DisableCalls(stub func(string) error) {
	fake.disableMutex.Lock()
	defer fake.disableMutex.Unlock()
	fake.DisableStub = stub
}

func (fake *FakeDistribution) DisableArgsForCall(i int) string {
	fake.disableMutex.RLock()
	defer fake.disableMutex.RUnlock()
	argsForCall := fake.disableArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDistribution) DisableReturns(result1 error) {
	fake.disableMutex.Lock()
	defer fake.disableMutex.Unlock()
	fake.DisableStub = nil
	fake.disableReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDistribution) DisableReturnsOnCall(i int, result1 error) {
	fake.disableMutex.Lock()
	defer fake.disableMutex.Unlock()
	fake.DisableStub = nil
	if fake.disableReturnsOnCall == nil {
		fake.disableReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.disableReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDistribution) Get(arg1 string) (*cloudfront.Distribution, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetStub
	fakeReturns := fake.getReturns
	fake.recordInvocation("Get", []interface{}{arg1})
	fake.getMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDistribution) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeDistribution) GetCalls(stub func(string) (*cloudfront.Distribution, error)) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *FakeDistribution) GetArgsForCall(i int) string {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDistribution) GetReturns(result1 *cloudfront.Distribution, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 *cloudfront.Distribution
		result2 error
	}{result1, result2}
}

func (fake *FakeDistribution) GetReturnsOnCall(i int, result1 *cloudfront.Distribution, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 *cloudfront.Distribution
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 *cloudfront.Distribution
		result2 error
	}{result1, result2}
}

func (fake *FakeDistribution) ListDistributions(arg1 func(cloudfront.DistributionSummary) bool) error {
	fake.listDistributionsMutex.Lock()
	ret, specificReturn := fake.listDistributionsReturnsOnCall[len(fake.listDistributionsArgsForCall)]
	fake.listDistributionsArgsForCall = append(fake.listDistributionsArgsForCall, struct {
		arg1 func(cloudfront.DistributionSummary) bool
	}{arg1})
	stub := fake.ListDistributionsStub
	fakeReturns := fake.listDistributionsReturns
	fake.recordInvocation("ListDistributions", []interface{}{arg1})
	fake.listDistributionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDistribution) ListDistributionsCallCount() int {
	fake.listDistributionsMutex.RLock()
	defer fake.listDistributionsMutex.RUnlock()
	return len(fake.listDistributionsArgsForCall)
}

func (fake *FakeDistribution) ListDistributionsCalls(stub func(func(cloudfront.DistributionSummary) bool) error) {
	fake.listDistributionsMutex.Lock()
	defer fake.listDistributionsMutex.Unlock()
	fake.ListDistributionsStub = stub
}

func (fake *FakeDistribution) ListDistributionsArgsForCall(i int) func(cloudfront.DistributionSummary) bool {
	fake.listDistributionsMutex.RLock()
	defer fake.listDistributionsMutex.RUnlock()
	argsForCall := fake.listDistributionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDistribution) ListDistributionsReturns(result1 error) {
	fake.listDistributionsMutex.Lock()
	defer fake.listDistributionsMutex.Unlock()
	fake.ListDistributionsStub = nil
	fake.listDistributionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDistribution) ListDistributionsReturnsOnCall(i int, result1 error) {
	fake.listDistributionsMutex.Lock()
	defer fake.listDistributionsMutex.Unlock()
	fake.ListDistributionsStub = nil
	if fake.listDistributionsReturnsOnCall == nil {
		fake.listDistributionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listDistributionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDistribution) SetCertificateAndCname(arg1 string, arg2 string, arg3 []string) error {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.setCertificateAndCnameMutex.Lock()
	ret, specificReturn := fake.setCertificateAndCnameReturnsOnCall[len(fake.setCertificateAndCnameArgsForCall)]
	fake.setCertificateAndCnameArgsForCall = append(fake.setCertificateAndCnameArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3Copy})
	stub := fake.SetCertificateAndCnameStub
	fakeReturns := fake.setCertificateAndCnameReturns
	fake.recordInvocation("SetCertificateAndCname", []interface{}{arg1, arg2, arg3Copy})
	fake.setCertificateAndCnameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDistribution) SetCertificateAndCnameCallCount() int {
	fake.setCertificateAndCnameMutex.RLock()
	defer fake.setCertificateAndCnameMutex.RUnlock()
	return len(fake.setCertificateAndCnameArgsForCall)
}

func (fake *FakeDistribution) SetCertificateAndCnameCalls(stub func(string, string, []string) error) {
	fake.setCertificateAndCnameMutex.Lock()
	defer fake.setCertificateAndCnameMutex.Unlock()
	fake.SetCertificateAndCnameStub = stub
}

func (fake *FakeDistribution) SetCertificateAndCnameArgsForCall(i int) (string, string, []string) {
	fake.setCertificateAndCnameMutex.RLock()
	defer fake.setCertificateAndCnameMutex.RUnlock()
	argsForCall := fake.setCertificateAndCnameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDistribution) SetCertificateAndCnameReturns(result1 error) {
	fake.setCertificateAndCnameMutex.Lock()
	defer fake.setCertificateAndCnameMutex.Unlock()
	fake.SetCertificateAndCnameStub = nil
	fake.setCertificateAndCnameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDistribution) SetCertificateAndCnameReturnsOnCall(i int, result1 error) {
	fake.setCertificateAndCnameMutex.Lock()
	defer fake.setCertificateAndCnameMutex.Unlock()
	fake.SetCertificateAndCnameStub = nil
	if fake.setCertificateAndCnameReturnsOnCall == nil {
		fake.setCertificateAndCnameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setCertificateAndCnameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDistribution) Update(arg1 string, arg2 *[]string, arg3 string, arg4 *int64, arg5 *utils.Headers, arg6 *bool) (*cloudfront.Distribution, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 string
		arg2 *[]string
		arg3 string
		arg4 *int64
		arg5 *utils.Headers
		arg6 *bool
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.UpdateStub
	fakeReturns := fake.updateReturns
	fake.recordInvocation("Update", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.updateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDistribution) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeDistribution) UpdateCalls(stub func(string, *[]string, string, *int64, *utils.Headers, *bool) (*cloudfront.Distribution, error)) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeDistribution) UpdateArgsForCall(i int) (string, *[]string, string, *int64, *utils.Headers, *bool) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeDistribution) UpdateReturns(result1 *cloudfront.Distribution, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *cloudfront.Distribution
		result2 error
	}{result1, result2}
}

func (fake *FakeDistribution) UpdateReturnsOnCall(i int, result1 *cloudfront.Distribution, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 *cloudfront.Distribution
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 *cloudfront.Distribution
		result2 error
	}{result1, result2}
}

func (fake *FakeDistribution) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.disableMutex.RLock()
	defer fake.disableMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.listDistributionsMutex.RLock()
	defer fake.listDistributionsMutex.RUnlock()
	fake.setCertificateAndCnameMutex.RLock()
	defer fake.setCertificateAndCnameMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDistribution) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ utils.DistributionIface = new(FakeDistribution)
